## 요약
- 스프링과 스프링 부트 핵심 사항
- 스프링 부트 생성하기
- 스프링 개요
---
## 개요
- 과거에는 `관계형 데이터베이스`를 사용하는 웹 브라우저 기반의 웹 어플리케이션이 가장 많이 개발되었다.
1. 이런 유형의 개발은 여전이 유효하지만 **마이크로서비스**로 구성된 애플리케이션의 개발에도 관심이 높다.
	- 다양한 데이터베이스에 데이터를 저장하는 **클라우드**에 맞추어져 있다.
2. **리액티브 프로그래밍**도 새로운 관심사가 되었다.
	- 더 큰 확장성과 향상된 성능을 제공한다.
- 마이크로 서비스와 리액티브 프로그래밍을 포함하는 최신 소프트웨어 개발의 관심사를 다루기 위해 스프링 프레임워크도 진화하였다.
	- **스프링 부트**도 추가되어 스프링 개발 모델을 간소화했다.

## 1.1 스프링이란?
- 대부분의 애플리케이션은 많은 **컴포넌트**로 구성된다.
	- 컴포넌트: 애플리케이션 전체 기능 중 일부를 담당한다.
	- 각 컴포넌트는 다른 컴포넌트와 협력해서 작업을 처리한다.
- 애플리케이션이 실행될 때는 각 컴포넌트가 어떻게든 생성되어야 하고, 상호 간에 알 수 있어야 한다.
- 스프링은 `스프링 애플리케이션 컨텍스트` 라는 **컨테이너** 를 제공한다.
	- 애플리케이션 컴포넌트들을 생성하고 관리한다.
	- 컴포넌트 또는 **빈**들은 스프링 애플리케이션 컨텍스트 내부에서 연결되어 완전한 애플리케이션을 만든다.
	- 예) 벽돌, 목재, 배관이 어우러져 집을 구성한다.
- `빈의 상호 연결`은 **의존성 주입**이라고 알려진 패턴을 기반으로 수행된다.
	- 컴포넌트에서 의존(사용)하는 다른 *빈의 생성과 관리를 자체적으로 하지 않고* **컨테이너**가 해준다.
	- 컨테이너에서는 모든 컴포넌트를 생성, 관리하고, 해당 컴포넌트를 필요로 하는 빈에 주입(연결)한다.
	- 일반적으로 생성자 인자 또는 속성의 접근자 메서드(getter; 변경자 = setter)를 통해 처리된다.

### 예시 - 재고 서비스
- 재고 서비스 : 여러 컴포넌트(빈) 중 재고 수준을 알아낸다.
- 제품 서비스 컴포넌트 : 제품 정보를 제공한다.
	- 제품에 대한 정보를 제공하기 때문에 재고 서비스에 의존한다.
```
			 주입(연결)
재고 서비스 ---------------> 제품 서비스
```

스프링 관련 라이브러리에서는 웹 프레임워크, 데이터 저장 옵션, 보안 프레임워크, 타 시스템과의 통합, 런타임 모니터링, 마이크로서비스 지원, 리액티브 프로그래밍 모델 등의 기능을 제공한다.

- 컴포넌트 사이의 관계를 나타내는 하나 이상의 XML 파일을 사용해서 빈을 상호 연결하도록 스프링 애플리케이션 컨텍스트(컨테이너)에 알려주었다.
- 최신 버전의 스프링에서는 자바 기반의 구성(configuration)을 더 많이 사용한다.
``` java
@Configuration
public class ServiceConfiguration {
	@Bean
	public InventoryService inventoryService() {
		return new InventoryService();
	}
}
```
- `@Configuration` : ServiceConfiguration이 각 빈을 스프링 애플리케이션 컨텍스트에 제공하는 구성 클래스임을 스프링에 알림
- `@Bean` : 구성 클래스의 메서드에 지정함. 각 메서드에서 반환되는 객체가 애플리케이션 컨텍스트의 빈으로 추가되어야 한다는 것을 나타냄.
	- 각 빈의 ID: 해당 빈을 정의하는 메서드의 이름
- 스프링은 자동으로 컴포넌트들을 구성할 수 있는 자동-구성 기능이 있다.
	- 그래서 자동-구성을 할 수 없을 경우에만 자바 기반 구성이 필요하다.
- **스프링 부트**가 나오면서 자동-구성 기능이 더욱 향상되었다.
	- 생산성 향상을 제공하는 스프링 프레임워크의 확장
	- 환경 변수인 `classpath`를 기준으로 어떤 컴포넌트가 구성되고 연결되어야하는지 알 수 있다.
	- 코드를 작성하지 않아도 컴포넌트가 활성화되고 자동-구성이 작동된다.
	- 스프링 부트의 자동-구성은 애플리케이션을 빌드하는 데 필요한 별도의 구성 코드(XML, configuration 등)를 현격히 줄여준다.

## 1.2 스프링 애플리케이션 초기 설정하기
> 타코를 주문하는 타코 클라우드 온라인 애플리케이션을 생성하자.
- `스프링 Initializr`(이니셜라이저)를 사용해서 애플리케이션을 초기 설정하자.
	- REST API를 사용하는 브라우저 기반의 웹 애플리케이션.
	- 스프링 프로젝트의 구조를 생성해 준다.
	- 다양한 방법으로 이니셜라이저를 사용할 수 있다.
- WAR : Web Application ARchive
	- 기존의 자바 웹 애플리케이션은 WAR 파일로 패키징된다.
	- 기존의 자바 애플리케이션 서버에 애플리케이션을 배포할 때 적합하다.
	- 그러나 대부분의 클라우드 플랫폼에는 잘 맞지 않는다.
	- 만약 기존의 자바 애플리케이션 서버에 타코 애플리케이션을 배포하고자 한다면 WAR을 선택하고 웹 초기 설정 클래스를 포함시켜야 한다.
- JAR : Java ARchive
	- 라이브러리와 데스크톱 ui 애플리케이션의 패키징에 사용된다.
	- 클라우드에 염두를 둔다.
	- 따라서 스프링 Initializr에서는 JAR 패키징을 기본값으로 사용한다.
- 의존성
	- 예시)
	- Spring Boot DevTools
	- Lombok
	- Thymeleaf
	- Spring Web
- 기본적으로 프로젝트 위저드는 `https://start.spring.io`의 스프링 Initializr를 호출하여 프로그램을 생성한다.
	- 만약 기본 Initializr를 로컬 컴퓨터에 복사했거나 회사 방화벽 내부에서 실행되는 커스터마이징된 Initializr가 있을 경우, 그 주소를 Base Url 로 설정한다.

### 1.2.2 스프링 프로젝트 구조 살펴보기
- 메이븐(Maven) 또는 그래들(Gradle) 프로젝트 구조이다.
- 애플리케이션 소스 코드 : `src/main/java`
- 테스트 코드 : `src/test/java`
- 자바 리소스 외의 코드 : `src/main/resource`

다음은 프로젝트 구조에서 알아 둘 주요 항목이다.
- mvnw와 mvnw.cmd : Maven 래퍼 스크립트이다. 메이븐이 컴퓨터에 설치되어 있지 않더라도 이 스크립트를 사용하여 프로젝트를 빌드할 수 있다.
- pom.xml : 메이븐 빌드 명세(프로젝트를 빌드할 때 필요한 정보)를 지정한 파일이다.
- TacoCloudApplication.java : 스프링 부트 메인 클래스
- application.properties : 처음에는 이 파일이 비어있지만, 우리가 구성 속성을 지정할 수 있다.
- static : 브라우저에 제공할 정적 콘텐츠(이미지, 스타일시트, 자바스크립트 등)를 둘 수 있는 폴더
- templates : 브라우저에 콘텐츠를 보여주는 템플릿 파일을 두는 폴더. Thymeleaf 템플릿을 추가할 수 있다.
- TacoCloudApplicationTests.java : 스프링 애플리케이션이 성공적으로 로드되는지 확인하는 간단한 테스트 클래스

#### 빌드 명세 살펴보기
우리 프로젝트는 현재 메이븐으로 빌드된다.
pom.xml은 빌드 명세를 정의한다.
- `<parent>` 요소의 `<version>` : 우리 프로젝트가 부모 POM(Project Object Model)으로 `spring-boot-start-parent`를 갖는다는 것을 지정한다.
	- 스프링 프로젝트에 자주 사용되는 여러 라이브러리의 의존성 관리를 제공한다.
	- 이런 라이브러리는 버전을 지정할 필요가 없다.
	- 이 스프링 부트 버전에 의해 정의된 의존성 관리를 계승한다.
- `<dependencies>` : 의존성이 정의된다.
	- STS 프로젝트 위저드(이클립스 툴) 등으로 이니셜라이저에서 선택한 각 의존성이 `<dependencies>` 요소로 지정된다.
	- 위에서 우리가 설정한 spring Web, Tymeleaf, Spring Boot DevTools, Lombok이 들어있고, 테스트를 작성할 것에 대비하여 스프링 이니셜라이저가 `spring-boot-starter-test`를 자동으로 추가해준다.
		- Spring Web, Tymeleaf, Test 의존성은 `<artifactId>`에 start 단어를 포함하고 있다.
		- 예) `<artifactId>spring-boot-starter-test</artifactId>`
		- 이것은 스프링 부트 스타터 의존성을 나타낸다.
		- 이 의존성 항목들은 자체적으로 라이브러리 코드를 갖지 않고 다른 라이브러리의 것을 사용한다.
	- 스타터 의존성의 장점
		1. 필요로 하는 모든 라이브러리의 의존성을 선언하지 않아도 되므로 빌드 파일이 작아지고 관리하기 쉬워진다.
		2. 라이브러리 이름이 아닌 기능의 관점으로 의존성을 생각할 수 있다.
			- 웹 애플리케이션을 개발한다면 웹 애플리케이션을 작성할 수 있게 해주는 라이브러리들을 일일이 지정하는 대신에 웹 스타터 의존성만 추가하면 된다.
		3. 라이브러리들의 버전을 걱정하지 않아도 된다.
			- 스프링 부트에 포함되는 라이브러리들의 버전은 호환이 보장된다.
			- 사용하려는 스프링 부트의 버전만 신경쓰면 된다.
- `<build>` -> `<plugin>` -> `<artifactId>spring--boot-maven-plugin</artifactId>`: pom.xml 파일의 제일 끝에는 스프링 부트 플러그인이 지정된다.
	- 스프링 부트 플러그인의 중요 기능
		- 메이븐을 사용하는 애플리케이션을 실행할 수 있게 해준다.
		- 의존성에 지정된 모든 라이브러리가 실행 가능 JAR 파일에 포함되어 있는지, 런타임 시에 classpath에서 찾을 수 있는지 확인한다.
		- 실행 가능 JAR 파일의 메인 클래스로 부트스트랩 클래스(우리는 TacoCloudApplication)를 나타내는 매니페스트 파일을 JAR 파일에 생성한다.

#### 애플리케이션의 부트스트랩(구동)
실행 가능한 JAR 파일에서 애플리케이션을 실행하므로 제일 먼저 시작되는 부트스트랩 클래스가 있어야 한다.
애플리케이션을 부트스트랩하기 위한 최소한의 스프링 구성도 있어야 한다.
``` java
@SpringBootApplication
public class TacoCloudApplication(String[] args) {
	SpringApplication.run(TacoCloudApplication.class, args);
}
```
- `@SpringBootApplication` : 이 코드가 스프링 부트 애플리케이션임을 나타낸다.
	- `@SpringBootApplication`은 다음 세 개의 애노테이션이 결합한 것이다.
	1. `@SpringBootConfiguration` : 현재 클래스를 구성 클래스로 지정한다. `@Configuration` 애노테이션의 특화된 형태이다.
	2. `@EnableAutoConfiguration` : 스프링 부트 자동-구성을 활성화한다. 필요로 하는 컴포넌트들을 자동으로 구성하도록 스프링 부트에 알려준다.
	3. `@ComponentScan` : 컴포넌트 검색을 활성화한다. 이것은 `@Component`, `@Controller`, `@Service` 등의 애노테이션과 함께 클래스를 선언할 수 있게 해준다. 그러면 스프링은 자동으로 그런 클래스를 찾아 스프링 애플리케이션 컨텍스트에 컴포넌트로 등록한다.
- `main()` 메서드는 JAR 파일이 실행될 때 호출되어 실행되는 메서드이다.

#### 애플리케이션 테스트하기
- 아래는 기본적인 애플리케이션 테스트이다.
``` java
@SpringBootTest
class TacoCloudApplicationTests {
	@Test
	void contextLoads() {
	}
}
```
- `SpringBootTest` : 스프링 부트 기능으로 테스트를 시작하라는 것을 JUnit에 알려준다.
	- `main()` 메서드의 SpringApplication.run() 호출에 부합되는 테스트 클래스를 나타낸다.

## 1.3 스프링 애플리케이션 작성하기
- 홈페이지의 웹 요청(request)을 처리하는 컨트롤러 클래스
- 홈페이지의 모습을 정의하는 뷰 템플릿

### 1.3.1 웹 요청 처리하기
- 스프링 MVC : 스프링의 ==웹 프레임워크==
	- 컨트롤러: 웹 요청과 응답을 처리하는 컴포넌트(구성요소)
	- 웹 브라우저를 상대하는 애플리케이션은 선택적으로 *Model 데이터를 채워서 응답*한다.
	- 브라우저에 반환되는 HTML을 생성하기 위해 *해당 응답의 웹 요청을 뷰에 전달*한다.
- 다음은 홈페이지 컨트롤러이다.
``` java
@Controller
public class HomeController {
	@GetMapping("/") // 루트 경로인 / 의 웹 요청을 처리
	public String home() {
		return "home"; // 뷰 이름인 home 반환
	}
}
```
 - `@Controller` : 컴포넌트 검색 시에 HomeController 클래스가 컴포넌트로 식별되게 한다.
	 - 스프링의 컴포넌트 검색에서는 자동으로 HomeController 클래스를 찾은 후 애플리케이션 컨텍스트의 빈으로 HomeController의 인스턴스를 생성한다.
	 - `@Component`, `@Service`, `@Repository` 등 또한 같은 역할을 한다.
- `home()` 메서드는 HTTP GET 메서드 요청이 수신되면 이 메서드가 해당 요청을 처리한다.
	- 뷰는 여러 방법으로 구현될 수 있지만 Thymeleaf가 우리의 classpath에 지정되어 있으므로 여기서는 Thymeleaf를 사용해서 뷰 템플릿을 정의할 수 있다.
		- Thymeleaf는 논리적인 뷰 이름 앞에 `/templates/`가 붙고 끝에는 `.html`이 추가된다.
		- 합쳐서 `/templates/home/html`이 된다.

### 1.3.2 뷰 정의하기
``` html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
	  xmlns:th="http://www.thymeleaf.org">
	  <head>
		  <meta charset="EUC-KR">
		  <title>Taco Cloud</title>
	  </head>
	  <body>
		  <h1>Welcome to...</h1>
		  <img th:src="@{/images/TacoCloud.png}"/>
	  </body>
</html>
```
- `<img>` 태그 안에서 타코 클라우드 로고를 보여준다. 이 태그에서는 컨텍스트의 **상대적인 경로**에 위치하는 이미지를 참조하는 @{...} 표현식을 사용해서 Thymeleaf의 th:src 속성을 지정한다.
- 이미지와 같은 정적인 콘텐츠는 /resource/static 에 있어야 한다.

### 1.3.3 컨트롤러 테스트하기
- 웹 어플리케이션 테스트는 까다롭다. HTML 페이지의 콘텐츠에 대한 assertion(우리가 원하는 것이 맞는지 테스트하기 위해 지정한 단언)을 설정하기가 어렵기 때문이다.
- 스프링은 웹 애플리케이션을 쉽게 테스트하는 강력한 테스트 지원 기능을 제공한다.
- 아래 테스트는 루트 경로인 / 의 HTTP GET 요청을 수행한 후 성공적인지, 뷰 이름이 home이고 "Welcome to..." 메시지가 포함된 결과가 기대한 대로 나오는지 테스트한다. 
``` java
@WebMvcTest(HomeController.class) // HomeController의 웹 페이지 테스트
public class HOmeControllerTest {
	@Autowired
	private MockMvc mockMvc; // MockMvc 주입

	@Test
	public void testHomePage() throws Exception {
		mockMvc.perform(get("/")) // GET / 을 수행
			.andExpect(status().isOk()) // HTTP 200이 되어야 한다.
			.andExpect(view().name("home")) // home 뷰가 있어야 한다.
			.andExpect(content().string(
				containsString("Welcom to..."))); // 콘텐츠에 'Welcome to...'가 포함되어야 한다.
	}
}
```
- `@WebMvcTest` : 스프링 MVC 애플리케이션의 형태로 테스트가 실행된다. HomeController가 스프링 MVC에 등록되므로 우리가 스프링 MVC에 웹 요청을 보낼 수 있다.
- 테스트에서는 실제 서버를 시작하는 대신 스프링 MVC의 모의 메커니즘을 사용해도 충분하므로 모의 테스트를 하기 위한 MockMvc 객체를 주입한다.
- testHomePage() 메서드에는 홈페이지에 대해 수행하고자 하는 테스트를 정의한다.
1. 우선 루트 경로인 / 의 HTTP GET 요청을 목 객체로 수행한다.
2. 기대하는 것(expectation)을 다음과 같이 설정한다.
	- 응답은 반드시 HTTP 200 상태
	- 뷰의 이름은 반드시 home
	- 브라우저에 보이는 뷰에는 반드시 'Welcome to...' 텍스트가 포함되어야 한다.

### 1.3.4 애플리케이션 빌드하고 실행하기
- 애플리케이션이 시작되었을 때 스프링 부트 대시보드 예시
	- `taco-cloud [devtools] [:8080]`
	- 프로젝트에 Spring Boot DevTools가 활성화 되어 있다.
	- 실행 중인 애플리케이션이 8080 포트로 동작한다.
- 톰캣에 애플리케이션을 설치하지 않았는데도 실행이 가능한 이유가 무엇일까?
- 스프링 부트 애플리케이션에는 실행에 필요한 모든 것이 포함된다. 따라서 톰캣과 같은 애플리케이션 서버에 별도로 애플리케이션을 설치할 필요가 없다. 톰캣이 우리 애플리케이션의 일부가 된 것이다.

### 1.3.5 스프링 부트 DevTools 알아보기
이름에서 암시하듯, DevTools는 스프링 개발자에게 다음과 같은 개발 시점의 편리한 도구를 제공한다.
- **코드가 변경**될 때 자동으로 애플리케이션을 **다시 시작**시킨다.
- 브라우저로 전송되는 리소스(템플릿, 자바 스크립트, 스타일시트)가 변경될 때 자동으로 브라우저를 새로고침한다.
- 템플릿 캐시를 자동으로 비활성화한다.
- H2 데이터베이스를 사용 중이라면 자동으로 H2 콘솔을 활성화한다.
개발 시에만 사용되도록 했으므로 실제 운영에서는 스스로 비활성화된다.(애플리케이션 배포시 비활성화)

#### 자동으로 애플리케이션 다시 시작시키기
- DevTools를 사용하면 프로젝트의 자바 코드와 속성 파일들을 변경할 때 곧바로 해당 변경이 적용된다.
- DevTools는 변경을 감시하며 *변경을 알게 되면 자동으로 애플리케이션을 다시 시작*시킨다.
- 더 자세히 말하면,
- DevtTools를 사용 중일 때 애플리케이션은 **JVM**에서 *두 개의 클래스 로더*에 의해 로드된다.
1. 그 중 하나는 src/main/ 경로에 있는 모든 것과 함께 로드된다.
2. 나머지 클래스 로더는 자주 변경되지 않는 *의존성 라이브러리*와 함께 로드된다.
- 변경이 감지되는 경우 DevTools는 프로젝트 코드를 포함하는 클래스 로더만 다시 로드하고 스프링 애플리케이션 컨텍스트를 다시 시작시킨다.
- 다른 클래스 로더와 JVM은 그대로 둔다.
- 그래서 애플리케이션이 시작하는데 걸리는 시간을 조금 단축할 수 있다.
- 이런 전략의 단점은 애플리케이션이 자동으로 다시 시작될 때 의존성 변경이 적용될 수 없다는 것이다.
	- 의존성 라이브러리를 포함한 클래스 로더는 자동으로 다시 로드되지 않기 때문이다.
- 따라서 빌드 명세(pom.xml)에 의존성을 추가, 변경, 삭제할 때는 애플리케이션을 새로 시작해야 한다.

#### 자동으로 브라우저를 새로고침하고 템플릿 캐시를 비활성화하기
- 기본적으로 Thymeleaf와 FreeMaker 같은 템플릿에서는 *템플릿의 파싱 결과*를 **캐시**에 저장하고 사용하도록 구성된다.
- 템플릿이 사용되는 모든 웹 요청마다 매번 다시 파싱 되지 않게 하기 위해서이다.
- 운영 시점에서는 좋지만, 개발 시점에는 템플릿 파싱이 유용하지 않다.
- 애플리케이션이 실행 중일 때 템플릿을 변경하고 브라우저를 새로고침하더라도 여전히 변경 전의 캐싱된 템플릿이 사용되므로 변경된 결과를 볼 수 없기 때문이다. (앱 다시 시작해야 변경사항을 볼 수 있다.)
- DevTools는 ==모든 템플릿 캐싱을 자동으로 비활성화==하여 이 문제를 해결한다.
- 브라우저만 새로고침 하면 변경된 템플릿이 적용된다.
- 그러나!! 브라우저의 새로고침 버튼을 클릭하는 것조차 귀찮다면?
- DevTools가 사용될 때 애플리케이션과 함께 자동으로 *LiveReload* 서버를 활성화한다.
- 브라우저에 전달되는 거의 모든 것에 변경이 생길 때 브라우저가 자동으로 새로고침 된다.
- 브라우저에 LiveReload 플러그인을 설치해서 사용하자!

#### H2 콘솔
- H2 콘솔도 DevTools가 자동으로 활성화해 준다.

### 1.3.6 리뷰하기
지금까지 했던 작업 단계를 요약해 보자.
1. 스프링 이니셜라이저를 사용해서 프로젝트 초기 구조를 생성하였다.
2. 홈페이지 웹 요청을 처리하기 위해 컨트롤러 클래스를 작성하였다.
3. 홈페이지를 보여주기 위해 뷰 템플릿을 정의하였다.
4. 애플리케이션을 테스트하기 위해 테스트 클래스를 작성하였다.

매우 간단하다!
스프링을 사용해 애플리케이션을 개발하면 프레임워크의 요구를 만족시키기 위한 코드보다는 애플리케이션의 요구를 충족하는 코드에 집중할 수 있다.
- 이것이 어떻게 가능할까? 
- 우리 애플리케이션의 요구를 충족하기 위해 스프링이 내부적으로 무슨 일을 할까?
- 스프링이 하는 일을 이해하기 위해 빌드 명세를 살펴보자.

빌드 명세를 정의한 pom.xml 파일에서 `Web`과 `Thymeleaf` 의존성을 선언했다. 이 두 의존성은 다음 내용을 비롯해서 일부의 다른 의존성도 포함시킨다.
- 스프링의 MVC 프레임워크
- 내장된 톰캣
- Thymeleaf와 Thymeleaf 레이아웃 dialect
이 때 스프링 부트의 **자동-구성 라이브러리**도 개입되므로 애플리케이션이 시작될 때 스프링 부트 자동-구성에서 그런 ==의존성 라이브러리들을 감지하고 자동으로 다음 일을 수행==한다.
- **스프링 MVC**를 활성화하기 위해 스프링 애플리케이션 컨텍스트에 관련된 **빈들을 구성**한다.
- 내장된 톰캣 서버를 스프링 애플리케이션 컨텍스트에 구성한다.
- Thymeleaf 템플릿을 사용하는 스프링 MVC 뷰를 나타내기 위해 **Thymeleaf 뷰 리졸버**를 구성한다.
자동-구성이 모든 작업을 수행하므로 우리는 애플리케이션 구현 코드를 작성하는데 집중할 수 있다.

## 1.4 스프링 살펴보기
중요한 의존성만 살펴보자.
### 1.4.1 핵심 스프링 프레임워크
- 스프링 MVC : 스프링 웹 프레임워크
	- 앞에서 배운 것 - 웹 요청을 처리하기 위해 스프링 MVC를 사용해서 컨트롤러 클래스를 작성한다.
	- NEW! - HTML이 아닌 출력을 생성하는 **REST API**를 만들 때도 스프링 MVC를 사용할 수 있다.
- 핵심 스프링 프레임워크는 템플릿 기반의 JDBC 지원(JdbcTemplate)을 포함해서 기본적인 데이터 persistance 지원도 제공한다.
- 스프링의 가장 최신 버전에서는 **리액티브 프로그래밍** 지원이 추가되었다.
	- 스프링 MVC 개념의 **스프링 WebFlux** 라는 새로운 리액티브 웹 프레임워크가 포함된다. 

### 1.4.2 스프링 부트
- 스타터 의존성과 자동-구성이 있다.
- 이 외에도 다음과 같은 편리한 기능을 제공한다.
- 액추에이터 : 애플리케이션의 내부 작동을 런타임 시에 살펴볼 수 있다.
	- 메트릭
	- 스레드 덤프 정보
	- 애플리케이션의 상태, 애플리케이션에서 사용할 수 있는 환경 속성
	- 을 포함한다.
- 환경 속성의 명세
- 핵심 프레임워크에 추가되는 테스트 지원
- 스프링 부트 CLI(명령형 인터페이스) : 애플리케이션 전체를 그루비 스크립트들로 작성하여 명령행에서 실행할 수 있다.

### 1.4.3 스프링 데이터
- 기본적인 데이터 퍼시스턴스 지원은 핵심 스프링 프레임워크에 포함되어 있지만, 스프링 데이터는 이외에도 더 좋은 기능을 제공한다.
- 간단한 자바 인터페이스로 애플리케이션의 데이터 리퍼지터리를 정의할 수 있다.
	- 데이터를 저장하고 읽는 메서드를 작명 규칙을 사용해서 정의한다.
- 서로 다른 종류의 데이터베이스와 함께 사용될 수 있다.
	- 예) JPA(관계형 데이터베이스), Mongo(문서형 데이터베이스) 등

### 1.4.4 스프링 시큐리티
- 스프링의 강력한 보안 프레임워크
- 인증, 허가, API 보안을 포함하는 폭넓은 범위의 애플리케이션 보안 요구를 다룬다.

### 1.4.5 스프링 통합과 배치
- 대부분의 애플리케이션은 다른 애플리케이션 또는 같은 애플리케이션의 서로 다른 컴포넌트를 통합할 필요가 있다.
- 이런 요구사항을 해결하기 위한 애플리케이션 통합 패턴이 있다.
- 스프링 통합과 배치는 스프링 기반 애플리케이션의 패턴 구현을 제공한다.
- 스프링 통합
	- 데이터가 사용 가능한 즉시 처리되는 실시간 통합을 한다.
- 스프링 배치
	- 다량의 데이터가 처리되는 시점을 트리거에게 알려줄 때 데이터가 수집 처리된다.

### 1.4.6 스프링 클라우드
- 요즘은 애플리케이션을 거대한 하나의 단일체로 개발하는 대신 마이크로서비스라는 여러 개의 개별적인 단위들로 합성한다.
- 마이크로서비스를 위해 스프링 클라우드를 사용한다.

